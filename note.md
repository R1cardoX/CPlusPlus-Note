# 简介 

摘录自wikipedia
C++是一种被广泛使用的计算机程序设计语言。它是一种通用程序设计语言，支持多重编程模式，例如过程化程序设计、数据抽象、面向对象程序设计、泛型程序设计和设计模式等。

比雅尼·斯特劳斯特鲁普博士在贝尔实验室工作期间在20世纪80年代发明并实现了C++。起初，这种语言被称作“C with Classes”（“包含‘类’的C语言”），作为C语言的增强版出现。随后，C++不断增加新特性。虚函数（virtual function）、运算符重载（operator overloading）、多继承（multiple inheritance）、标准模板库（standard template library, STL）、异常处理（exception）、运行时类型信息（runtime type information）、名字空间（namespace）等概念逐渐纳入标准。1998年，国际标准组织（ISO）颁布了C++程序设计语言的第一个国际标准ISO/IEC 14882:1998，目前最新标准为ISO/IEC 14882:2020。根据《C++编程思想》（Thinking in C++）一书，C++与C的代码执行效率往往相差在±5%之间。

## C++名字的由来

C++这个名字是Rick Mascitti于1983年中所建议的，并于1983年12月首次使用。更早以前，尚在研究阶段的发展中语言曾被称为“new C”，之后是“C with Classes”。在计算机科学中，C++仍被称为C语言的上层结构。它最后得名于C语言中的“++”运算符（其对变量的值进行递增）。而且在共同的命名约定中，使用“+”以表示增强的程序。斯特劳斯特鲁普说：“这个名字象征着源自于C语言变化的自然演进”。C+是一个和C/C++无关的早期编程语言。

## 设计原则

在《C++语言的设计和演化》（1994）中，Bjarne Stroustrup描述了他在设计C++时，所使用的一些原则。知道这些原则有助于理解C++为何会是现在这个样子。以下总结了一些原则，详尽的内容可参阅《C++语言的设计和演化》：

- C++设计成直接的和广泛的支持多种程序设计风格（过程化程序设计、数据抽象、面向对象编程、泛型程序设计）。
- C++设计成给程序设计者更多的选择，即使可能导致程序设计者选择错误。
- C++设计成尽可能与C兼容，借此提供一个从C到C++的平滑过渡。
- C++避免平台限定或没有普遍用途的特性。
- C++不使用会带来额外开销的特性。
- C++设计成无需复杂的程序设计环境。

## 标准程序库

1998的C++标准分为两个部分：核心语言和C++标准程序库；后者包含了大部分标准模板库和C标准程序库的稍加修改版本。存在许多不属于标准部分的C++程序库，且使用外部链接，程序库甚至可以用C撰写。

C++标准程序库充分吸收了C标准程序库，并佐以少许的修改，使其与C++良好的运作。另一个大型的程序库部分，是以标准模板库（STL）为基础，STL于1994年2月正式成为ANSI/ISO C++。它提供了实用的工具，如容器类（如：Array和Vector），迭代器（广义指针）提供容器以类似数组的访问方式，以及泛型算法进行搜索和排序的运算。此外还提供了(multi)map和(multi)set，它们都共享相似的成员函数。因此，以下成为可能，使用模板撰写泛型算法，它可以和任何容器或在任何以迭代器定义的序列上运作。如同C，使用#include指令包含标准表头，即可访问程序库里的功能。C++提供69个标准表头，其中19个不再赞成使用。

使用标准模板库（例如：使用std::vector或std::string来取代C风格的数组或字符数组）有助于导向更安全和更灵活的软件。

在STL在纳入C++标准以前，是来自HP和后来的SGI的第三方程式库，标准中并未称之为“STL”，它只是标准库中的一部分，但仍有许多人使用这个名称，以别于其它的标准库（输入／输出流、国际化、诊断、C程序库子集，等等）。 另外，如std::basic_string此类标准委员会添加的接口，有时也被误认为STL；实际上它们并不存在于原始的SGI STL中，在标准化后SGI STL才从标准库吸收加入其中。
# 基本概念 

引用自cppreference
一个 C++ 程序是一个含有声明的文本文件（通常为头文件与源文件）序列。它们被翻译成一个可执行程序，C++ 实现通过调用其主 (main) 函数执行这一程序。

在 C++ 程序中，一些被称为关键词的词语有着特殊的含义。其它词语可以被用作标识符。在翻译的过程中，注释会被忽略。程序中的某些特定字符必须通过转义序列表示。

C++ 程序中的实体包括值、对象、引用、 结构化绑定 (C++17 起)、函数、枚举项、类型、类成员、模板、模板特化、命名空间和形参包。预处理器宏不是 C++ 实体。

声明可以引入实体，将它们与名字关联起来，并定义其属性。能够定义使用一个实体所需的所有属性的声明是定义。对任何被 ODR 使用的非内联函数或变量，程序中必须只含有其一个定义。

函数的定义通常包括一系列的语句，其中部分会包含表达式。表达式指定了程序需要进行的运算。

程序中遇到的名字通过名字查找与引入它们的声明关联起来。每个名字都只在称为其作用域的程序部分中有效。有些名字有链接，这使得它们即使出现在不同的作用域或翻译单元时也代表相同的实体。

C++ 中的每一个对象、引用、函数和表达式都会关联一个类型。类型可以分为基础类型，复合类型，或自定义类型，以及完整或不完整的类型等。

被声明的且不是非静态数据成员的对象和引用是变量。

## Hello World
```cpp
#include <iostream> //引用名为iostream的c++标准库，并不是所有的程序都需要引用这个头文件这个头文件可以解释为io stream理解为输入输出流

int main() { //主函数 程序从这里开始
    std::cout << "Hello, world!" << std::endl; //使用cout函数输出一个字符串，使用endl表示结尾需要换行。
    return 0; //根据ISO C++的规定，全局main函数必须返回int。 
}
```

当然主函数也可以这么写，这样的话就可以传入命令行的参数了，argc是命令行参数的个数，argv是命令行参数组成的数组，注意argv[0]是程序本身参数是从下标1开始
```cpp
int main(int argc, char *argv[]) {
    // ...
}
```
当然你也可以为这个hello world做进一步的简化但并不推荐这么做：
使用`using namespace std;`避免在cout、endl前声明std，使用'\n'代替endl
```cpp
#include <iostream>
using namespace std;
int main() {
    cout << "Hello, world!\n";
    return 0;
}
```
## 编译和执行程序
在这里只简单的介绍如何在Linux用g++来编译C++，以便于可以使用该技巧来验证自己的程序

```shell
g++ -std=c++11 helloworld.cpp -o app #这里暂时使用c11的规范进行编译整篇文章是基于c17的，甚至可能会提到c20的某些新特性
```
通过执行上面这条语句将helloworld.cpp 编译成名为app的可执行文件

## 注释

注释的作用可以是方便读者去理解代码或者是暂时不让某块代码运行

在C++中可以有多种注释方式，比较常见的是以下两种：

```cpp
/* 这是一段注释 */
//这是一段注释
```

还有另一种写法：

```cpp
#if 0
    std::cout << "这一句不会被执行，甚至不会被编译\n";
#endif
```
由于使用了宏（后面会详细讲解）操作在预编译阶段就将该段代码抹去了

## 关键字
为C++中的保留字，是为语言所服务的 详情见https://zh.cppreference.com/w/cpp/keyword

## 标识符
标识符是一个由数字，下划线，大小写拉丁字母和大多数 Unicode 字符组成的任意长度的序列。有效的标识符必须以一个非数字字符（拉丁字母，下划线或类为 XID_Start 的 Unicode 字符）开头，而在非开头位置可以有非数字字符、数字及类为 XID_Continue 的 Unicode 字符。标识符区分大小写（小写和大写字母是不同的），而且每一个字符都是起作用的。每个标识符都必须遵循正规化形式 C。

可以用标识符来命名对象、引用、函数、枚举项、类型、类成员、命名空间、模板、模板特化、形参包、goto 标号，以及其他实体，注意标识符不能是关键字。
## 类型
对象、引用、函数（包括函数模板特化）和表达式具有称为类型的性质，它限制了对这些实体所容许的操作，并给原本寻常的位序列提供了语义含义。
类型可以分为基础类型和复合类型。

命名一个类型
- 类声明：`class Type;`
- 联合体声明： `struct Type;`
- 枚举声明： `enum Type;`
- typedef 声明：`typedef int my_int;`
- 类型别名声明： `using my_int = int;` 

附：https://zh.cppreference.com/w/cpp/language/type

注：typedef和类型别名的区别，类和联合体的区别。

## 对象
C++ 程序可以创建、销毁、引用、访问并操作对象。

在 C++ 中，一个对象拥有这些性质：

- 大小（可以使用 sizeof 获取）；
- 对齐要求（可以使用 alignof 获取）；
- 存储期（自动、静态、动态、线程局部）；
- 生存期（与存储期绑定或者临时）
- 类型；
- 值（可能是不确定的，例如默认初始化的非类类型）；
- 名字（可选）。

以下实体都不是对象：值，引用，函数，枚举项，类型，类的非静态成员，模板，类或函数模板的特化，命名空间，形参包，和 this。

变量由声明所引入，是一个对象或不是对非静态数据成员的引用。

## 模块
todo

## 作用域
C++ 程序中出现的每个名字，只在某些可能不连续的源码部分中有效，这些部分被称为其作用域。

在作用域内，能用无限定名字查找将名字与其声明关联起来。

## 生成期
每个对象和引用都有生存期 (lifetime) ，这是一项运行时性质：每个对象或引用在程序执行时都存在一个时刻开始其生存期，也都存在一个时刻结束其生存期。

## 翻译阶段
在编译器处理C++文件时会通过9个阶段处理C++的源文件

https://zh.cppreference.com/w/cpp/language/translation_phases

# 预处理器
预处理器是在翻译阶段中的第四个阶段执行的

预处理指令包括：define、undef、include、if、ifdef、ifndef、else、elif、endif、line、error、pragma、import

其基本形式为'#'字符 + 预处理指令 + 参数（如果需要）+ 换行符

## 分类
条件包含（#if、#ifdef、#ifndef、#else、#elif 和 #endif）

文本替换（#define 和 #undef 指令与 # 和 ## 运算符）。

错误指令 （#error）

源文件包含（#include 指令控制并以 __has_include 检查 (C++17 起)）。

实现定义的行为控制（由 #pragma 指令和 _Pragma 运算符 (C++11 起)控制）。

文件名和行信息（#line）
